# Data Flow & State Management

> How image data moves from Firebase through caching layers to the UI, and how the modal/auth state machines work.

## Data Lifecycle Overview

```
Firebase Storage
  │
  ▼
storageService.fetchAllImageMetadata() / fetchAllVideoMetadata()    ← Fetches metadata + URLs for all images and videos
    │
    ▼
GalleryContext (GalleryProvider)           ← Central state owner
    │
    ├──► mediaCacheService (IndexedDB)     ← Caches thumbnail blobs for instant restore
    │
    ├──► imageMetas[]                      ← Metadata array available to all pages
    ├──► preloadedImages[]                 ← Thumbnail blob URLs for grid rendering
    ├──► resolveThumbUrl(meta)             ← Best-effort thumbnail resolution
    │
    └──► Modal state (isModalOpen, modalImages, etc.)
              │
              ▼
         GalleryModalRenderer → mediaModalViewer
              │
              └──► Full-res on-demand loading (windowed ±N or preloadAll)
```

## Service Layer

### `storageService.ts`

**Single responsibility:** Read media metadata from Firestore (`images` and `videos` collections), then resolve signed download URLs from Firebase Storage for the file paths stored on those docs. Returns typed `ImageMeta[]` and `VideoMeta[]`.

```typescript
type ImageMeta = {
  id: string; // filename (e.g. "photo1.jpg")
  storagePath: string; // "images/full/photo1.jpg"
  date: string; // ISO string, normalized
  event?: string; // from Firestore doc
  caption?: string; // from Firestore doc
  downloadUrl: string; // full-res download URL (signed)
  thumbUrl: string; // thumbnail download URL (falls back to downloadUrl)
};

type VideoMeta = {
  id: string; // filename (e.g. "video1.mp4")
  type: "video";
  date: string; // ISO string, normalized
  event?: string; // from Firestore doc
  caption?: string; // from Firestore doc
  videoPath: string; // Storage path like "videos/full/video1.mp4"
  thumbUrl: string; // poster thumbnail URL (resolves from thumbPath or falls back)
};
```

**`fetchAllImageMetadata()`** and **`fetchAllVideoMetadata()`** do:

1. `getDocs(collection(db, "images"))` / `getDocs(collection(db, "videos"))` to load Firestore docs
2. For each doc, read the storage paths (`fullPath` / `videoPath` and `thumbPath`) and build signed URLs with `getDownloadURL(ref(storage, path))`
3. Normalize `date` from the Firestore field (supports ISO string or Firestore Timestamp). If missing/invalid, fall back to `new Date().toISOString()`
4. If a thumb download fails, fall back to the full download URL (maintains existing fallback behavior)
5. Return results sorted **newest-first** by date

**Key details:**

- Metadata now comes from Firestore documents (`images` / `videos`). Do not rely on Storage object `customMetadata`.
- If a thumbnail doesn't exist in `images/videos/thumb/`, the service falls back to the full-res URL
- Date parsing is defensive — supports Firestore Timestamp objects and ISO strings, otherwise falls back to `new Date().toISOString()`

### `eventsService.ts`

**Single responsibility:** Talk to Firestore for timeline events. Returns typed `TimelineEvent[]`.

```typescript
type TimelineEvent = {
  id: string; // Firestore document ID (generated by Firestore)
  date: string; // YYYY-MM-DD format
  title: string; // Event title
  emojiOrDot?: string; // Emoji or "•" for display
  imageIds?: string[]; // Associated image IDs
};
```

**`fetchEvents()`** does:

1. `query(collection(db, "events"), orderBy("date", "desc"))` to get all events
2. Maps Firestore documents to `TimelineEvent` objects
3. Returns sorted **newest-first** by date

**Key details:**

- Events are stored in Firestore `events` collection
- Document ID serves as the event `id` field
- Events can be created/updated via the uploader page
- Images link to events via explicit `imageIds` array or matching `event` metadata

### `authService.ts`

Thin wrapper around Firebase Auth. Uses `config.authEmail` for the login identifier.

| Method                       | What it does                                         |
| ---------------------------- | ---------------------------------------------------- |
| `signInWithPassword(pw)`     | `signInWithEmailAndPassword(auth, EMAIL, pw)`        |
| `signOut()`                  | `signOut(auth)`                                      |
| `subscribeToAuthChanges(cb)` | `onAuthStateChanged(auth, cb)` — returns unsubscribe |

**Rule:** Never call Firebase Auth directly. Use `useAuth()` hook which wraps `authService`.

Security note: this email value is not a security boundary. Backend protection is provided by Firebase Security Rules.

### `mediaCacheService.ts`

IndexedDB-backed thumbnail cache with two object stores:

| Store         | Key            | Value                     |
| ------------- | -------------- | ------------------------- |
| `image-blobs` | `ImageMeta.id` | `Blob` (thumbnail JPEG)   |
| `meta`        | `"manifest"`   | `ImageMeta[]` (full list) |

**Public API:**

| Function                        | Purpose                                                                       |
| ------------------------------- | ----------------------------------------------------------------------------- |
| `loadFromCache()`               | Returns `{ metas, preloaded }` or `null` if no cache                          |
| `syncCache(fresh, onProgress?)` | Diffs fresh vs cached, downloads new thumbs, evicts removed, updates manifest |
| `clearCache()`                  | Wipes both stores (called on logout)                                          |

**`syncCache` algorithm:**

1. Read all cached blob keys from IndexedDB
2. Compute diff: `toDownload` = IDs in fresh but not cached, `toRemove` = cached but not in fresh
3. Evict removed blobs
4. Download new thumbnails in batches of 60 (parallel within batch)
5. Build full `PreloadedImage[]` from cache + new downloads
6. Persist updated manifest
7. Return all preloaded images with blob URLs

## Context Layer

### `AuthContext`

**State:**

- `user: User | null` — Firebase User object
- `initializing: boolean` — true until first `onAuthStateChanged` fires

**Methods:**

- `login(password)` — calls `authService.signInWithPassword`
- `logout()` — calls `authService.signOut`

**Lifecycle:** Sets up `onAuthStateChanged` listener on mount, cleans up on unmount.

### `GalleryContext`

The **central data hub**. Owns image metadata, video metadata, events, preloaded blobs, loading state, and modal state.

**State shape:**

```typescript
{
  events: TimelineEvent[];           // Timeline events from Firestore, newest-first
  refreshEvents: () => Promise<void>; // Refresh events from Firestore
  refreshGallery: () => Promise<void>; // Refresh image/video metadata
  imageMetas: ImageMeta[];           // All image metadata, newest-first
  videoMetas: VideoMeta[];           // Video metadata (posters + meta)
  preloadedImages: PreloadedImage[]; // Thumbnail blob URLs
  isGalleryLoading: boolean;         // True while fetching
  hasGalleryLoadedOnce: boolean;     // Flips true after first successful load
  loadError: string | null;
  loadingProgress: number;           // 0-100

  // Modal state
  isModalOpen: boolean;
  modalMedia: MediaMeta[];           // Modal can show mixed images/videos
  modalInitialIndex: number;
  modalPreloadAll: boolean;          // Preload ALL full-res images vs windowed ±N
}
```

**Loading sequence (runs when `user` becomes non-null):**

```
1. Start events fetch (non-blocking, runs in parallel)
2. Check IndexedDB cache (loadFromCache)
   ├── Cache hit  → Show cached data instantly, set hasGalleryLoadedOnce = true
   └── Cache miss → Show loading progress starting at 20%
3. Fetch fresh metadata from Firebase (fetchAllImageMetadata + fetchAllVideoMetadata)
4. Diff-sync cache (syncCache) — downloads only NEW thumbnails
5. Update state with fresh data + events
6. Release old blob URLs to prevent memory leaks
```

**On logout / auth loss:**

- `resetState()` clears all state fields to defaults
- `clearCache()` wipes IndexedDB
- This is automatic via the `useEffect` watching `user`

**Modal API:**

| Method                                 | Use Case                                                                      |
| -------------------------------------- | ----------------------------------------------------------------------------- |
| `openModalWithImages(imgs, opts?)`     | Open lightbox with a specific image set                                       |
| `openModalForImageId(id, collection?)` | Open lightbox at a specific image, optionally within a subset                 |
| `openModalWithMedia(media, opts?)`     | Open media modal with images and/or videos (timeline only allows mixed media) |
| `closeModal()`                         | Close the lightbox                                                            |
| `updateModalIndex(idx)`                | Sync index when user swipes in the modal                                      |

**`OpenModalOptions`:**

```typescript
{
  initialIndex?: number;   // Start at this index
  imageId?: string;        // Find this ID in the array and start there
  preloadAll?: boolean;    // If true, preload full-res for ALL images (used by timeline)
}
```

### `ToastContext`

Simple notification system.

```typescript
toast(message: string, variant?: "success" | "error" | "logout")
```

- Auto-dismisses after 1500ms with a 350ms exit animation
- Renders at a fixed position via `ToastContainer`
- Three visual variants with distinct pastel color schemes

## Hooks

### `useFullResLoader`

Used by `HomePage` and `PhotosPage` to track and resolve full-resolution download URLs.

- **`HomePage`** requests full-res URLs for its 6/9 chosen tiles while showing thumbnails immediately.
- **`PhotosPage`** requests full-res URLs for visible year groups and evicts off-screen groups.

```typescript
const { resolveUrl, requestFullRes, evict, hasFullRes } = useFullResLoader();

requestFullRes(metas); // Mark full-res URLs as wanted for these items
const url = resolveUrl(meta, thumbUrl); // Returns full-res download URL or fallback
evict(keepIds); // Remove full-res URLs not in the keep-set
const ready = hasFullRes(id); // Check if a specific image has full-res loaded
```

- Stores Firebase download URLs in-memory per image ID
- Deduplicates updates via `loadingIdsRef`
- Does not fetch image bytes directly; the browser loads bytes via `<img src="downloadUrl">`

### `usePageReveal`

Returns a boolean that flips `true` shortly after mount (default 20ms delay + `requestAnimationFrame`).

```typescript
const isVisible = usePageReveal(40); // optional delay in ms
// Use in className: isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-4"
```

Every page uses this for entrance animations. **Always apply it to new pages.**

### `useGalleryLoadingProgress` (legacy)

Standalone hook that fetches metadata + preloads thumbnails. **Not currently used by the main flow** (replaced by `GalleryContext`'s internal loading). Kept for reference.

## Image Resolution Pipeline

Images go through multiple resolution stages:

```
Upload flow:
  Original file → convertToJpeg() → full-res JPEG (quality 0.9)
                → generateThumbnail() → 480px thumb JPEG (quality 0.7)
                → Upload both to Firebase Storage

Display flow:
  1. IndexedDB cache → thumbnail blob URL (instant, ~50ms)
  2. Firebase thumb URL → fallback if no cache
  3. useFullResLoader → full-res download URL (browser loads directly)
  • HomePage: progressive upgrade — thumbnails shown immediately, full-res overlaid as they load
  • All: progressive upgrade (thumbnail shown first, full-res overlaid)
  4. mediaModalViewer → full-res download URL for images (browser loads directly). Videos are played on demand using `getVideoDownloadUrl()`; posters are used as thumbnails.
```

## Memory Management

The codebase is careful about blob URL lifecycle:

- **`GalleryContext`**: Calls `URL.revokeObjectURL` on old `preloadedImages` (thumbnail blobs) when replacing
- **`mediaCacheService`**: Manages thumbnail blob URLs from IndexedDB cache, revokes on eviction
- **`GalleryContext.resetState`**: Releases preloaded thumbnail URLs on logout

Full-resolution images are now loaded directly by the browser via Firebase download URLs, eliminating the need for blob URL management for full-res content.
